pipeline {
  agent any
  environment {
    IMAGE_NAME = 'flask-shopping-list'  // change if you like
  }
  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Build') {
      steps {
        // optional diagnostics
        bat 'where docker'
        bat 'docker --version'

        // Compute COMMIT + IMAGE_TAG, then build and save artefact
        bat '''
          setlocal ENABLEDELAYEDEXPANSION
          for /f %%i in ('git rev-parse --short HEAD') do set COMMIT=%%i
          set IMAGE_TAG=%BUILD_NUMBER%-%COMMIT%

          if not exist build mkdir build

          docker build -t %IMAGE_NAME%:%IMAGE_TAG% .

          docker images --no-trunc --quiet %IMAGE_NAME%:%IMAGE_TAG% > build\\image-id.txt
          echo %IMAGE_NAME%:%IMAGE_TAG% > build\\image-tag.txt

          docker save -o build\\%IMAGE_NAME%-%IMAGE_TAG%.tar %IMAGE_NAME%:%IMAGE_TAG%
        '''
      }
    }
stage('Test - Unit') {
  steps {
    bat '''
      setlocal ENABLEDELAYEDEXPANSION
      for /f %%i in ('git rev-parse --short HEAD') do set COMMIT=%%i
      set IMAGE_NAME=flask-shopping-list
      set IMAGE_TAG=%BUILD_NUMBER%-%COMMIT%

      if exist reports rmdir /s /q reports
      mkdir reports\\junit

      docker run --rm ^
        -e CI_IN_CONTAINER=1 ^
        -e PYTHONPATH=/app ^
        -v "%cd%\\tests":/tests ^
        -v "%cd%\\reports":/tests/reports ^
        -w /tests ^
        %IMAGE_NAME%:%IMAGE_TAG% ^
        sh -lc "pip install -q pytest pytest-cov && \
                pytest -q --color=no \
                  --maxfail=1 --disable-warnings \
                  --cov=app --cov-report=term:skip-covered \
                  --cov-report=xml:/tests/reports/coverage.xml \
                  --cov-fail-under=85 \
                  --junitxml=/tests/reports/junit/pytest-unit.xml"
    '''
  }
  post {
    always {
      junit 'reports/junit/pytest-unit.xml'
      archiveArtifacts artifacts: 'reports/**', fingerprint: true
    }
  }
}


stage('Test - Smoke') {
  steps {
    bat '''
      setlocal ENABLEDELAYEDEXPANSION
      for /f %%i in ('git rev-parse --short HEAD') do set COMMIT=%%i
      set IMAGE_NAME=flask-shopping-list
      set IMAGE_TAG=%BUILD_NUMBER%-%COMMIT%
      set PORT=5001

      docker rm -f sl_test 2>nul || echo ok
      docker run -d --name sl_test -p %PORT%:5000 %IMAGE_NAME%:%IMAGE_TAG%

      powershell -Command "$ErrorActionPreference='Stop'; \
        $ok=$false; for($i=0;$i -lt 30;$i++){ \
          try{ $r=Invoke-WebRequest http://localhost:%PORT%/health -UseBasicParsing; if($r.StatusCode -eq 200){ $ok=$true; break } } \
          catch { Start-Sleep -s 2 } \
        }; if(-not $ok){ Write-Error 'App did not become healthy in time'; exit 1 }; \
        $l=Invoke-WebRequest http://localhost:%PORT%/login -UseBasicParsing; \
        if($l.StatusCode -ne 200){ Write-Error 'Login page not OK'; exit 1 }"
      docker rm -f sl_test
    '''
  }
  post {
    failure {
      bat 'echo --- sl_test logs --- & docker logs sl_test || echo (no container) & docker rm -f sl_test || exit /b 0'
    }
  }
}
stage('Code Quality') {
  steps {
    script {
      // Resolve the installed scanner
      def scannerHome = tool name: 'HD', type: 'hudson.plugins.sonar.SonarRunnerInstallation'

      // Inject SONAR_HOST_URL and SONAR_TOKEN from the "HD" server config
      withSonarQubeEnv('HD') {
        // Run the scanner (properties file + a few CLI overrides)
        bat """
          "${scannerHome}\\bin\\sonar-scanner.bat" ^
            -Dsonar.projectVersion=%BUILD_NUMBER% ^
            -Dsonar.host.url=%SONAR_HOST_URL%
        """
      }
    }
  }
}

stage('Security') {
  steps {
    withEnv(["PYTHONWARNINGS=ignore"]) {
      script {
        bat """
        if not exist reports mkdir reports
        if not exist reports\\junit mkdir reports\\junit

        docker run --rm -v "%cd%":/work -w /work python:3.11-slim sh -lc "pip install --no-cache-dir pip-audit bandit >/dev/null 2>&1; \
          pip-audit -r requirements.txt -f json -o reports/pip-audit.json || true; \
          bandit -r app -iii -q -f xml -o reports/bandit.xml || true"

        rem -- read image tag saved in the Build stage
        set /p IMG=<build\\image-tag.txt

        rem -- Trivy table report
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock -v "%cd%\\reports":/reports aquasec/trivy:0.53.0 ^
          image %IMG% --ignore-unfixed --scanners vuln --severity HIGH,CRITICAL ^
          --format table --output /reports/trivy-image.txt || exit /b 0

        rem -- Trivy SARIF (for Warnings NG / SARIF)
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock -v "%cd%\\reports":/reports aquasec/trivy:0.53.0 ^
          image %IMG% --ignore-unfixed --scanners vuln --severity HIGH,CRITICAL ^
          --format sarif --output /reports/trivy-image.sarif || exit /b 0
        """
      }
    }

    // Optional publishers (won’t fail the build if missing)
    recordIssues enabledForFailure: true, tools: [sarif(pattern: 'reports/trivy-image.sarif')]
    archiveArtifacts artifacts: 'reports/**', fingerprint: true
  }
}
stage('Deploy - Staging') {
  // keep your when{} guard if you want; removing it makes this always run
  steps {
    script {
      bat '''
        setlocal ENABLEDELAYEDEXPANSION

        rem --- prep folders & files ---
        if not exist deploy mkdir deploy
        if not exist reports mkdir reports
        copy /Y docker-compose.staging.yml deploy\\docker-compose.staging.yml >NUL
        copy /Y staging.env                 deploy\\staging.env >NUL

        rem --- read image tag written in Build stage (e.g. "flask-shopping-list:46-abc1234") ---
        for /f %%i in (build\\image-tag.txt) do set "IMAGE=%%i"
        echo Using image: !IMAGE!

        rem --- stop previous stack (ignore errors if nothing is up) ---
        pushd deploy
        docker compose -p sl_staging -f docker-compose.staging.yml down --remove-orphans || echo ok

        rem --- export IMAGE so ${IMAGE} in compose gets resolved ---
        set "IMAGE=!IMAGE!"
        docker compose -p sl_staging -f docker-compose.staging.yml up -d --remove-orphans
        popd
      '''

      // Health check (PowerShell, no caret escaping needed)
      powershell '''
$ErrorActionPreference = "Stop"
$ok = $false
for ($i = 0; $i -lt 60; $i++) {
  try {
    $r = Invoke-WebRequest "http://localhost:5002/health" -UseBasicParsing
    if ($r.StatusCode -eq 200) { $ok = $true; break }
  } catch { Start-Sleep -Seconds 2 }
}
if (-not $ok) { throw "Staging app did not become healthy in time" }
'''
    }
  }
  post {
    success {
      echo 'Staging deployed & healthy at http://localhost:5002'
    }
    failure {
      bat 'if not exist reports mkdir reports'
      bat 'docker compose -p sl_staging -f deploy\\docker-compose.staging.yml ps   > reports\\deploy-ps.txt   || echo ok'
      bat 'docker compose -p sl_staging -f deploy\\docker-compose.staging.yml logs > reports\\deploy-logs.txt || echo ok'
      archiveArtifacts artifacts: 'reports/deploy-*.txt', fingerprint: true
    }
  }
}


stage('Release - Production') {
  // keep/remove a branch guard if you want; here we allow manual promotion from any branch
  steps {
    script {
      // Manual approval
      input message: "Promote build ${env.BUILD_NUMBER} to PRODUCTION?", ok: 'Deploy'

      // Tag + deploy with Docker Compose
      bat '''
        setlocal ENABLEDELAYEDEXPANSION

        rem --- prepare folders ---
        if not exist deploy mkdir deploy
        if not exist reports mkdir reports
        copy /Y docker-compose.production.yml deploy\\docker-compose.production.yml >NUL

        rem --- read the image that was built in the Build stage ---
        for /f %%i in (build\\image-tag.txt) do set "IMAGE=%%i"
        echo Releasing image: !IMAGE!

        rem --- tag for prod and latest (local) ---
        for /f "tokens=1 delims=:" %%a in ("!IMAGE!") do set "IMGNAME=%%a"
        for /f "tokens=2 delims=:" %%a in ("!IMAGE!") do set "IMGTAG=%%a"
        set "PROD_TAG=!IMGNAME!:prod-%BUILD_NUMBER%"
        set "LATEST_TAG=!IMGNAME!:latest"

        docker tag "!IMAGE!" "!PROD_TAG!"
        docker tag "!IMAGE!" "!LATEST_TAG!"

        rem --- keep a backup of last-good for rollback ---
        if exist build\\prod-last-good.txt copy /Y build\\prod-last-good.txt build\\prod-last-good.prev >NUL 2>&1
        echo !PROD_TAG! > build\\prod-candidate.txt

        rem --- deploy prod stack ---
        pushd deploy
        docker compose -p sl_prod -f docker-compose.production.yml down --remove-orphans || echo ok

        rem --- export IMAGE for compose substitution ---
        set "IMAGE=!PROD_TAG!"
        docker compose -p sl_prod -f docker-compose.production.yml up -d --remove-orphans
        popd
      '''

      // Health gate (run as real PowerShell, no caret/quoting headaches)
      powershell '''
$ErrorActionPreference = "Stop"
$ok = $false
for ($i = 0; $i -lt 90; $i++) {
  try {
    $r = Invoke-WebRequest "http://localhost:5003/health" -UseBasicParsing
    if ($r.StatusCode -eq 200) { $ok = $true; break }
  } catch {
    Start-Sleep -Seconds 2
  }
}
if (-not $ok) {
  Write-Error "PROD app did not become healthy in time"
  exit 1
}
'''

      // mark this image as last-good only after health passes
      bat '''
        copy /Y build\\prod-candidate.txt build\\prod-last-good.txt >NUL
        echo Production release healthy.
      '''
    }
  }
  post {
    success {
      echo "✅ Production deployed & healthy at http://localhost:5003"
    }
    failure {
      echo '❌ Production deploy failed – attempting rollback...'

      // Diagnostics (ensure IMAGE is set so compose parses)
      bat '''
        if not exist reports mkdir reports

        rem read the candidate image (if present) so ${IMAGE} resolves
        set "IMAGE="
        if exist build\\prod-candidate.txt (
          for /f %%i in (build\\prod-candidate.txt) do set "IMAGE=%%i"
        )

        pushd deploy
        if defined IMAGE (
          set IMAGE=%IMAGE%
        ) else (
          rem fallback to a dummy so compose still parses
          set IMAGE=flask-shopping-list:latest
        )
        docker compose -p sl_prod -f docker-compose.production.yml ps   > "..\\reports\\prod-ps.txt"   || echo ok
        docker compose -p sl_prod -f docker-compose.production.yml logs > "..\\reports\\prod-logs.txt" || echo ok
        popd
      '''

      // Roll back to last known good (if available)
      bat '''
        setlocal ENABLEDELAYEDEXPANSION
        if exist build\\prod-last-good.txt (
          for /f %%i in (build\\prod-last-good.txt) do set "ROLLBACK=%%i"
          echo Rolling back to !ROLLBACK!

          pushd deploy
          docker compose -p sl_prod -f docker-compose.production.yml down --remove-orphans || echo ok
          set "IMAGE=!ROLLBACK!"
          docker compose -p sl_prod -f docker-compose.production.yml up -d --remove-orphans || echo ok
          popd

          echo Rollback attempted. Check health at http://localhost:5003/health
        ) else (
          echo No last-good image found. Manual intervention required.
        )
      '''
      archiveArtifacts artifacts: 'reports/prod-*.txt', fingerprint: true
    }
  }
}
stage('Monitoring & Alerting') {
  steps {
    script {
      // Who to alert (set a real list or a Jenkins secret/param)
      env.ALERT_TO = env.ALERT_TO ?: 'you@example.com'

      // 1) Check Docker container health (compose project: sl_prod, service: web)
      bat '''
        rem --- capture health status of the running prod container ---
        for /f "tokens=*" %%i in ('docker ps --format "{{.Names}}" ^| findstr /I "sl_prod-web"') do set "PROD_CONT=%%i"
        if not defined PROD_CONT (
          echo No running prod container found (sl_prod-web-1). 
          echo HEALTH=missing> build\\monitor-health.txt
          exit /b 0
        )

        for /f "tokens=* delims=" %%i in ('docker inspect -f "{{.State.Health.Status}}" "%PROD_CONT%" 2^>NUL') do set "HEALTH=%%i"
        if not defined HEALTH set HEALTH=unknown
        echo HEALTH=%HEALTH%> build\\monitor-health.txt
        echo Container: %PROD_CONT%  Health: %HEALTH%
      '''

      // 2) Hit the /health endpoint several times; record status & latency
      powershell '''
$ErrorActionPreference = "Stop"
$uri = "http://localhost:5003/health"
$tries = 5
$okCount = 0
$latencies = @()

for ($i=0; $i -lt $tries; $i++) {
  $sw = [System.Diagnostics.Stopwatch]::StartNew()
  try {
    $r = Invoke-WebRequest -UseBasicParsing -Uri $uri -TimeoutSec 5
    $sw.Stop()
    $latencies += $sw.ElapsedMilliseconds
    if ($r.StatusCode -eq 200) { $okCount++ }
  } catch {
    $sw.Stop()
    $latencies += 9999
  }
  Start-Sleep -Seconds 1
}

$avg = [math]::Round(($latencies | Measure-Object -Average).Average, 1)
$p95 = [math]::Round(($latencies | Sort-Object | Select-Object -Last [int]([math]::Ceiling($tries*0.95)))[-1], 1)
$summary = "ok=$okCount/$tries avg_ms=$avg p95_ms=$p95"
$summary | Set-Content -Path "build\\monitor-http.txt"
Write-Host "HTTP check: $summary"
'''

      // 3) Grep recent logs for obvious errors
      bat '''
        if not exist reports mkdir reports
        docker compose -p sl_prod -f deploy\\docker-compose.production.yml logs --since=5m > reports\\prod-last5m.log 2>&1 || echo ok
        findstr /I /C:"ERROR" /C:"Traceback" /C:"CRITICAL" reports\\prod-last5m.log > reports\\prod-errors.log 2>&1 || echo ok
      '''

      // 4) Decide + alert (simple policy: container not healthy OR < 4/5 OK OR p95 > 800ms OR error lines found)
      script {
        def health = readFile('build/monitor-health.txt').trim().replace('HEALTH=','')
        def http = readFile('build/monitor-http.txt').trim()
        // parse http summary: ok=K/N avg_ms=A p95_ms=P
        def m = (http =~ /ok=(\d+)\/(\d+)\s+avg_ms=(\d+(?:\.\d+)?)\s+p95_ms=(\d+(?:\.\d+)?)/)
        int ok = 0, total = 0; double p95 = 9999
        if (m.find()) { ok = m.group(1).toInteger(); total = m.group(2).toInteger(); p95 = m.group(4).toDouble() }
        def errorsLog = fileExists('reports/prod-errors.log') ? readFile('reports/prod-errors.log') : ''
        boolean hasErrors = errorsLog?.trim()

        def failReasons = []
        if (!['healthy','starting'].contains(health)) failReasons << "Container health = ${health}"
        if (ok < Math.max(4, (int)Math.ceil(0.7* (total?:5)))) failReasons << "HTTP success $ok/$total below threshold"
        if (p95 > 800) failReasons << "HTTP p95 ${p95}ms > 800ms"
        if (hasErrors) failReasons << "Errors found in logs (last 5m)"

        if (failReasons) {
          currentBuild.result = 'UNSTABLE'
          // Email alert (requires Email Extension plugin configured)
          emailext(
            subject: "[ALERT][${env.JOB_NAME} #${env.BUILD_NUMBER}] Prod monitor warnings",
            to: env.ALERT_TO,
            body: """<p><b>Monitoring detected issues:</b></p>
                     <ul>${failReasons.collect{ "<li>${it}</li>" }.join('')}</ul>
                     <p><b>Health:</b> ${health}<br/>
                        <b>HTTP:</b> ${http.replaceAll('<','&lt;')}<br/>
                        <b>Logs (last 5m):</b> attached</p>
                     <p>Build: ${env.BUILD_URL}</p>""",
            attachmentsPattern: 'reports/prod-last5m.log'
          )
          echo "Monitoring flagged issues: ${failReasons.join('; ')}"
        } else {
          echo "Monitoring OK: health=${health}, ${http}"
        }
      }
    }
  }
  post {
    always {
      archiveArtifacts artifacts: 'build/monitor-*.txt,reports/prod-*.log', fingerprint: true
    }
  }
}


    stage('Archive artefacts') {
      steps {
        archiveArtifacts artifacts: 'build/**', fingerprint: true
      }
    }
  }
}
